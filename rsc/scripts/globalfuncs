#!/bin/bash

# function declarations

function sleepfor()
{
  echo "sleeping for $1 seconds..."
  sleep $1
}

function rem_blanks()
{
  local array="$1"
  local i=""
  for i in $array ; do echo -n $i ; done
}

function getAquParams()
{
  local conftxt="$1"
  local col=$2
  local subj="$3"
  local sess="$4"
  local param=""
  local line=""
  
  if [ ! -f $conftxt ] ; then echo "defineBOLDparams(): ERROR: info file '$conftxt' not found. You will need to create that file..." >&2 ; exit 1 ; fi
  
  if [ "$3" = "" ] ; then
  
    param=`cat $conftxt |  grep -v ^# | sed -n 1p | awk -v column="$col" '{printf("%s\n", $column)}'`
    if [ "$param" = "." -o x"$param" = "x"] ; then
      echo "getAquParams(): ERROR: entry in column $col no found..." >&2 ; exit 1
    else 
      echo "$param"
    fi
    
  else

    if [ "$sess" = "." ] ; then sess="" ; fi # no multisession design ?
     
    line=`cat $conftxt | awk '{print $1}' | grep -nx ${subj}${sess} | cut -d : -f1`  
    if [ -z $line ] ; then
      if [ "$sess" != "" ] ; then
        line=`cat $conftxt | awk '{print $1}' | grep -nx ${subj} | cut -d : -f1`
        echo "getAquParams(): WARNING: info file ${conftxt}: no entry found for string '${subj}${sess}'; trying to list FI entry for string '${subj}' instead..." >&2
      fi
    fi  
    if [ -z $line ] ; then echo "getAquParams(): ERROR: Unwarp info file ${conftxt}: no entry found for string '${subj}'. Exiting..." >&2 ; exit 1 ; fi

    param=`cat $conftxt |  sed -n ${line}p | awk -v column="$col" '{printf("%s\n", $column)}'`
   
    if [ "$param" = "." -o x"$param" = "x" ] ; then
      echo "getAquParams(): ERROR: entry in column $col no found..." >&2 ; exit 1
    else 
      echo "$param"
    fi
    
  fi
}

function defineBOLDparams()
{
  local conftxt="$1"
  local subj="$2"
  local sess="$3"
  
  if [ $getTR_bold -eq 1 -o $getTE_bold -eq 1 -o $getEES_bold -eq 1 ] ; then echo -n "defineBOLDparams(): subj $subj , sess $sess: " ; fi
  
  if [ $getTR_bold -eq 1 ] ; then TR_bold=`getAquParams $conftxt 2 $subj $sess` ; echo -n "TR = $TR_bold  " ; fi
  if [ $getTE_bold -eq 1 ] ; then TE_bold=`getAquParams $conftxt 3 $subj $sess` ; echo -n "TE = $TE_bold  " ;  fi
  if [ $getEES_bold -eq 1 ] ; then EES_bold=`getAquParams $conftxt 4 $subj $sess` ; echo -n "ESP = $EES_bold  " ;  fi
  
  if [ $getTR_bold -eq 1 -o $getTE_bold -eq 1 -o $getEES_bold -eq 1 ] ; then echo "" ; fi
}

function defineDWIparams()
{
  local conftxt="$1"
  local subj="$2"
  local sess="$3"
  
  if [ $getTR_diff -eq 1 -o $getTE_diff -eq 1 -o $getEES_diff -eq 1 -o $getTROT_topup -eq 1 ] ; then echo -n "defineDWIparams(): subj $subj , sess $sess: " ; fi

  if [ $getTR_diff -eq 1 ] ; then TR_diff=`getAquParams $conftxt 2 $subj $sess` ; echo -n "TR = $TR_diff  " ;  fi
  if [ $getTE_diff -eq 1 ] ; then TE_diff=`getAquParams $conftxt 3 $subj $sess` ; echo -n "TE = $TE_diff  " ;  fi
  if [ $getEES_diff -eq 1 ] ; then EES_diff=`getAquParams $conftxt 4 $subj $sess` ; echo -n "ESP = $EES_diff  " ;  fi
  if [ $getTROT_topup -eq 1 ] ; then TROT_topup=`getAquParams $conftxt 5 $subj $sess` ; echo -n "TROT = $TROT_topup  " ;  fi
  
  if [ $getTR_diff -eq 1 -o $getTE_diff -eq 1 -o $getEES_diff -eq 1 -o $getTROT_topup -eq 1 ] ; then echo "" ; fi
}

function concat_bvecs()
{
 local file_pttrn=$1
 local dest=$2
 local concat0=""
 local concat1=""
 local concat2=""
 local bvec_txt=""
 local bvecs0=""
 local bvecs1=""
 local bvecs2=""

 for bvec_txt in `ls $file_pttrn` ; do
  echo "  `basename $bvec_txt`"  
	bvecs0=`sed -n 1p $bvec_txt`
	bvecs1=`sed -n 2p $bvec_txt`
	bvecs2=`sed -n 3p $bvec_txt`
	concat0=$concat0" "$bvecs0
	concat1=$concat1" "$bvecs1
	concat2=$concat2" "$bvecs2
 done 

 echo $concat0 > ${dest}
 echo $concat1 >> ${dest}
 echo $concat2 >> ${dest}
  
 wc ${dest}
}

function concat_bvals()
{
  local file_pttrn=$1
  local dest=$2
  local bval_txt=""
  local bvals=""
  local concat=""
  
  for bval_txt in `ls ${file_pttrn}` ; do
  echo "  `basename $bval_txt`"
	bvals=`cat $bval_txt`
	concat=$concat" "$bvals
  done  

  echo $concat > ${dest}
  wc ${dest}
}

function findIndex() 
{
  local i=0;
  local bvals=`cat $1`
  local b0val=$2
  local b=""

  for b in $bvals ; do
   if test $b -eq $b0val -a $i -gt -1 ; then # take first B0 image ? (!)
     echo "$i"
     break
   fi
   i=$[$i+1]
  done
}

function getClusterJobID() 
{
  local user=`whoami | cut -c 1-10`
  qstat | grep $user | sort | tail -n 1 | awk '{print $1}'
}

function isClusterBusy() 
{ 
  if [ "x$SGE_ROOT" = "x" ] ; then echo "0"; return; fi # is cluster environment present ?
  
  # does qstat work ?
  qstat &>/dev/null
  if [ $? != 0 ] ; then 
    echo "ERROR : qstat failed. Is Network available ?" >&2
    echo "1"
    return
  fi
  
  local user=`whoami | cut -c 1-10`
  local n_total=`qstat | grep $user | wc -l`
  local n_dr=`qstat | grep $user| awk '{print $5}' | grep dr | wc -l`
  local n_dt=`qstat | grep $user| awk '{print $5}' | grep dt | wc -l` 
  echo "$n_total - $n_dr - $n_dt" | bc -l # ignore zombie jobs
}

function waitIfBusy() 
{
  if [ `isClusterBusy` -gt 0 ] ; then
    echo -n "waiting..."
    while [ `isClusterBusy` -gt 0 ] ; do echo -n '.' ; sleep 30 ; done
    echo "done."
  fi
}

function getBetThres() 
{
  local line=""
  local thres=""
  local bet_txt=$1
  local subj=$2
  local sess=$3
  
  if [ ! -f $bet_txt ] ; then echo "getBetThres(): ERROR: BET info file $bet_txt not found. You will need to create that file..." >&2 ; exit 1 ; fi
  
  if [ "$sess" = "." ] ; then sess="" ; fi # no multisession design ?
   
  line=`cat $bet_txt | awk '{print $1}' | grep -nx ${subj}${sess} | cut -d : -f1`  
  if [ -z $line ] ; then
    if [ "$sess" != "" ] ; then
      line=`cat $bet_txt | awk '{print $1}' | grep -nx ${subj} | cut -d : -f1`
      echo "getBetThres(): WARNING: BET info file ${bet_txt}: no entry found for string '${subj}${sess}'; trying to list FI entry for string '${subj}' instead..." >&2
    fi
  fi  
  if [ -z $line ] ; then echo "getBetThres(): ERROR: BET info file ${bet_txt}: no entry found for string '${subj}'. Exiting..." >&2 ; exit 1 ; fi

  thres=`cat $bet_txt | awk '{print $2}' | sed -n ${line}p `
  
  if [ "$thres" = "na" ] ; 
    then echo "n.a." # not available
  elif [ "$thres" = "mod" ] ; 
    then echo "mod" # externally modified
  else 
    echo "$thres"
  fi 
}

function getBetCoG() 
{
  local line=""
  local x="" ; local y="" ; local z=""
  local bet_txt=$1
  local subj=$2
  local sess=$3
  
  if [ ! -f $bet_txt ] ; then echo "getBetCoG(): ERROR: BET info file $bet_txt not found. You will need to create that file..." >&2 ; exit 1 ; fi

  if [ "$sess" = "." ] ; then sess="" ; fi # no multisession design ?

  line=`cat $bet_txt | awk '{print $1}' | grep -nx ${subj}${sess} | cut -d : -f1`
  if [ -z $line ] ; then
    if [ "$sess" != "" ] ; then
      line=`cat $bet_txt | awk '{print $1}' | grep -nx ${subj} | cut -d : -f1`
      echo "getBetCoG(): WARNING: BET info file ${bet_txt}: no entry found for string '${subj}${sess}'; trying to list CoG entry for string '${subj}' instead..." >&2
    fi
  fi
  if [ -z $line ] ; then echo "getBetCoG(): ERROR: BET info file ${bet_txt}: no entry found for string '${subj}'. Exiting..." >&2 ; exit 1 ; fi
  
  x=$(cat $bet_txt | awk '{print $3}' | sed -n ${line}p  )
  y=$(cat $bet_txt | awk '{print $4}' | sed -n ${line}p  )
  z=$(cat $bet_txt | awk '{print $5}' | sed -n ${line}p  )
  
  if [ "$x" = "na" -o "$y" = "na" -o "$z" = "na" ] ; 
    then echo "n.a." # not available
  elif [ "$x" = "mod" -o "$y" = "mod" -o "$z" = "mod" ] ; 
    then echo "mod" # externally modified
  else 
    echo "$x $y $z"
  fi
}

function getUnwarpDir() 
{
  local line=""
  local dir=""
  local unwarp_txt=$1
  local subj=$2
  local sess=$3
  
  if [ ! -f $unwarp_txt ] ; then echo "getUnwarpDir(): ERROR: Unwarp info file $unwarp_txt not found. You will need to create that file..." >&2 ; exit 1 ; fi
  
  if [ "$sess" = "." ] ; then sess="" ; fi # no multisession design ?
   
  line=`cat $unwarp_txt | awk '{print $1}' | grep -nx ${subj}${sess} | cut -d : -f1`  
  if [ -z $line ] ; then
    if [ "$sess" != "" ] ; then
      line=`cat $unwarp_txt | awk '{print $1}' | grep -nx ${subj} | cut -d : -f1`
      echo "getUnwarpDir(): WARNING: Unwarp info file ${unwarp_txt}: no entry found for string '${subj}${sess}'; trying to list FI entry for string '${subj}' instead..." >&2
    fi
  fi  
  if [ -z $line ] ; then echo "getUnwarpDir(): ERROR: Unwarp info file ${unwarp_txt}: no entry found for string '${subj}'. Exiting..." >&2 ; exit 1 ; fi

  dir=`cat $unwarp_txt | awk '{print $2}' | sed -n ${line}p `
  
  if [ "$dir" = "na" ] ; 
    then echo "n.a." # not available
  elif [ "$dir" = "mod" ] ; 
    then echo "mod" # externally modified
  else 
    echo "$dir"
  fi 
}

function getT1Sess4FuncReg() 
{
  local line=""
  local T1sess=""
  local func2struc_txt=$1
  local subj=$2
  local sess=$3
  
  if [ ! -f $func2struc_txt ] ; then echo "getT1Sess4FuncReg(): ERROR: Info file ${func2struc_txt} not found. You will need to create that file..." >&2 ; exit 1 ; fi
  
  if [ "$sess" = "." ] ; then sess="" ; fi # no multisession design ?
   
  line=`cat $func2struc_txt | awk '{print $1}' | grep -nx ${subj}${sess} | cut -d : -f1`  
  if [ -z $line ] ; then
    if [ "$sess" != "" ] ; then
      line=`cat $func2struc_txt | awk '{print $1}' | grep -nx ${subj} | cut -d : -f1`
      echo "getT1Sess4FuncReg(): WARNING: Info file ${func2struc_txt}: no entry found for string '${subj}${sess}'; trying to list FI entry for string '${subj}' instead..." >&2
    fi
  fi  
  if [ -z $line ] ; then echo "getT1Sess4FuncReg(): ERROR: Info file ${func2struc_txt}: no entry found for string '${subj}'. Exiting..." >&2 ; exit 1 ; fi

  T1sess=`cat $func2struc_txt | awk '{print $2}' | sed -n ${line}p `
  
  if [ "$T1sess" = "." ] ; then T1sess="" ; fi 
  
  echo "$T1sess"
}

function getBetCoGOpt()
{
  local CoG="$1"
  
  if [ "$CoG" = "n.a." ] ; then echo "" ; else echo "-c $CoG" ; fi
}

function getBetFIOpt()
{
  local FI="$1"
  
  if [ "$FI" = "n.a." ] ; then echo "" ; else echo "-f $FI" ; fi
}

function countVols()
{
  local file_pattern=$1
  local summand0=0
  local summand1=0
  local n_total=0
  local file=""
  
  if [ `ls $file_pattern | wc -l` -eq 0 ] ; then echo "countVols(): ERROR: <$file_pattern> not found - exiting..." >&2 ; exit 1 ; fi

  for file in `ls $file_pattern` ; do
    summand1=`fslinfo  $file | grep ^dim4 | awk '{print $2}'`
    n_total=`echo "$summand0 + $summand1" | bc`
    summand0=$n_total;
  done
  echo "$n_total"
}

#function gatherFilesAcrossSessions()
#{
  #local subjpath=$1
  #local sessions_txt=$2
  #local file_pattern=$3
  #local total=""
  #local n=""
  #local sess=""

  
  #for sess in `cat ${subjpath}/${sessions_txt}` ; do
    #n=`ls ${subjpath}/${sess}/${file_pattern}`
    #total=$total" "$n
  #done
  #echo $total
#}

function row2col()
{
  local dat=`cat $1`
  local i=""
  for i in $dat ; do echo $i ; done
}

function minmaxavg() # NB: min / max values are clamped to whole numbers
{
  awk 'NR == 1 { max=$1; min=$1; sum=0 }
  { if ($1>max) max=$1; if ($1<min) min=$1; sum+=$1;}
  END {printf "%d:%d:%f\n", min, max, sum/NR}'
}

function getMin() # finds minimum in column
{
  minmaxavg | cut -d ":" -f 1 
}

function getMax() # finds maximum in column
{
  minmaxavg | cut -d ":" -f 2 
}

function getAvg() # averages column
{
  minmaxavg | cut -d ":" -f 3
}

function subj_sess() # remove '.' replacement in filename if no multiple sessions
{
  echo "${subj}_${sess}" | sed  's/'$subj'_\./'$subj'/'
}

function subjsess() # remove '.' replacement in filename if no multiple sessions
{
  echo "${subj}${sess}" | sed  's/'$subj'\./'$subj'/'
}

function transpose()
{
  local matrix_txt="$1"
  
  awk -F " " '{
  for (f = 1; f <= NF; f++)
  a[NR, f] = $f
  }
  NF > nf { nf = NF }
  END {
  for (f = 1; f <= nf; f++)
  for (r = 1; r <= NR; r++)
  printf a[r, f] (r==NR ? RS : FS)
  }' "$matrix_txt"
}

function getIdx() 
{
  local i=0;
  local vals=`cat $1` ; local val=""
  local target=$2

  for val in $vals ; do
    if test $val -eq $target ; then
      echo "$i"
    fi
    i=$[$i+1]
  done
}

function readLinesInFile()
{
  local input="$1"
  local p0="$2" # begin line-number (start with 0)
  local p1="$3" # end line-number
  local n=0 # counter
  local line=""
  
  while read line
  do
    if [ $n -ge "$p0" -a $n -lt "$p1" ] ; then
      echo $line
    fi
    n=$(( $n + 1 ))
  done < "$input"
}

function average()
{  
  awk '
  FNR==NR {
  for(i=1; i<=NF; i++)
  _[FNR,i]=$i
  next
  }
  {
  for(i=1; i<=NF; i++)
  printf("%.7f%s", ($i+_[FNR,i])/2, (i==NF) ? "\n" : FS);
  }' $1 $2
}

function getB0Index()
{ 
  if [ "x$1" = "x" -o "x$2" = "x" ] ; then echo "usage:  getB0Index <bval file> <dest dir>" ; fi
  
  local bval_pttrn=$1
  local dest=$2
  local min=""
  local b0img=""
    
  concat_bvals "$bval_pttrn" bvals_concat.tmp > /dev/null
  
  min=`row2col bvals_concat.tmp | getMin` # find minimum value (usually representing the "B0" image)
  b0img=`findIndex bvals_concat.tmp $min`
  rm bvals_concat.tmp
  
  echo "$b0img" > $dest  
  echo "$b0img $min"
}

function checkConsistency()
{
  if [ "x$1" = "x" -o "x$2" = "x" -o "x$3" = "x" ] ; then echo "usage: checkConsistency <DWI file-pattern> <bval file> <bvec file>" ; fi
  
  local diff_pttrn="$1"
  local bval_file="$2"
  local bvec_file="$3"
  local nvol=""
  local n_bvals=""
  local n_bvecs=""
  
  if [ $(ls $diff_pttrn 2>/dev/null | wc -l) -eq 0 ] ; then echo "checkConsistency(): ERROR: DWI file pattern <$diff_pttrn> not found - skipping consistency check..." ; return ; fi
  if [ $(ls $bval_file 2>/dev/null | wc -l) -eq 0 ] ; then echo "checkConsistency(): ERROR: DWI bval file '$bval_file' not found - skipping consistency check..." ; return ; fi
  if [ $(ls $bvec_file 2>/dev/null | wc -l) -eq 0 ] ; then echo "checkConsistency(): ERROR: DWI bvec file '$bvec_file' not found - skipping consistency check..." ; return ; fi
  
  # number of entries in bvals- and bvecs files consistent ?
  nvol=`countVols "$diff_pttrn"` # check pattern (!)
  n_bvals=`cat $bval_file | wc -w` ; n_bvecs=`cat $bvec_file | wc -w`
  if [ $n_bvals = $nvol -a  $n_bvecs = `echo "3*$n_bvals" | bc -l` ] ; then
    echo "checkConsistency(): number of entries in bvals- and bvecs files are consistent with number of DWI volumes ($nvol entries)."
  else
    echo "checkConsistency(): ERROR : number of entries in bvals- and bvecs files are NOT consistent [bvals=$n_bvals; bvecs=$n_bvecs/3; DWIs=$nvol] !"
  fi  
}

function eddy_correct_plot() # from andreas bartsch, adapted
{  
  local logfile=$1;
  local subj=$2 # added by HKL
  local basenm=`basename $logfile .ecclog`;  
  local nums=`grep -n 'Final' $logfile | sed 's/:.*//'`
  local firsttime=yes ; local m=1 ; local n="" ; local n1="" ; local n2="" ; local absval="" ; local relval=""
 
  # clean up temp files that may have been created in prev. runs
  /bin/rm -f grot_labels.txt grot.oldmat grot.refmat grot.mat grot_ts.txt ec_disp.txt ec_rot.txt ec_trans.txt
 
  touch grot_ts.txt ; touch grot.mat
  echo -n "Timepoint "
  for n in $nums ; do 
      echo -n "$m "
      n1=`echo $n + 1 | bc` ; 
      n2=`echo $n + 5 | bc` ;
      sed -n  "$n1,${n2}p" $logfile > grot.mat ; 
      if [ $firsttime = yes ] ; then firsttime=no; cp grot.mat grot.refmat ; cp grot.mat grot.oldmat ; fi
      absval=`$FSLDIR/bin/rmsdiff grot.mat grot.refmat $basenm`;
      relval=`$FSLDIR/bin/rmsdiff grot.mat grot.oldmat $basenm`;
      cp grot.mat grot.oldmat
      echo $absval $relval >> ec_disp.txt ;
      $FSLDIR/bin/avscale --allparams grot.mat $basenm | grep 'Rotation Angles' | sed 's/.* = //' >> ec_rot.txt ;
      $FSLDIR/bin/avscale --allparams grot.mat $basenm | grep 'Translations' | sed 's/.* = //' >> ec_trans.txt ;
      m=`echo $m + 1 | bc`;
  done
  echo ""

  echo "absolute" > grot_labels.txt
  echo "relative" >> grot_labels.txt

  $FSLDIR/bin/fsl_tsplot -i ec_disp.txt -t "Subj. $subj - Eddy Current estimated mean displacement (mm)" -l grot_labels.txt -o ec_disp.png

  echo "x" > grot_labels.txt
  echo "y" >> grot_labels.txt
  echo "z" >> grot_labels.txt

  $FSLDIR/bin/fsl_tsplot -i ec_rot.txt -t "Subj. $subj - Eddy Current estimated rotations (radians)" -l grot_labels.txt -o ec_rot.png
  $FSLDIR/bin/fsl_tsplot -i ec_trans.txt -t "Subj. $subj - Eddy Current estimated translations (mm)" -l grot_labels.txt -o ec_trans.png
  
  ## assemble plots
  #montage -tile 1x3 -mode Concatenate ec_trans.png ec_rot.png ec_disp.png ec_diff.png 

  # clean up temp files
  /bin/rm grot_labels.txt grot.oldmat grot.refmat grot.mat grot_ts.txt ec_disp.txt ec_rot.txt ec_trans.txt
}

function ztransf4D()
{
  local file=$1
  local mask=$2
  local dst=$3
  local basenm=`basename $file`
  
  fslmaths $file -Tmean $dst/mean_${basenm}
  fslmaths $file -Tstd $dst/std_${basenm}
  if [ -f $mask ] ; then
    echo "ztransf4D(): using '$mask' as mask..."
    fslmaths $file -sub $dst/mean_${basenm} -div $dst/std_${basenm} -mas $mask $dst/ztransf_${basenm}
  else
    echo "ztransf4D(): WARNING: '$mask' not found - don't using any mask..."
    fslmaths $file -sub $dst/mean_${basenm} -div $dst/std_${basenm} $dst/ztransf_${basenm}
  fi
}

function prepareTBSS()
{
  local sourcedir="$1"
  local FAdir="$2"
  local destdir="$3"
  local pttrn_files="$4"
  local reg_opt="$5" # -T (register to std. template, recommended) or -n (register to group template) (!)
  local DEL="$6"
  local wd=`pwd` # define crurrent working directory
  
  # tbss subdir already present ?
  if [ -d ${destdir} -a $DEL -eq 0 ] ; then read -p "prepareTBSS(): Directory <${destdir}> already exists. Press any key to continue or Control-C to abort..." ; fi
  if [ -d ${destdir} -a $DEL -eq 1 ] ; then 
    if [ `echo ${destdir} | grep $tbssdir | wc -l` -eq 0 ] ; then # test, whether destination paths is plausible to avoid accidental deletions
      echo "prepareTBSS(): ERROR: The destination path ($destdir) is not under the tbss directory ($tbssdir). No deletions made. Exiting..." ; exit 1
    else 
      echo "prepareTBSS(): WARNING: Directory <${destdir}> already exists - deleting it as requested in 5 seconds !" ; sleep 5
      rm -r ${destdir}
    fi
  fi
  
  # create directory
  mkdir -p ${destdir}
  
  # are files already present for processing ? Otherwise copy from subjdir...
  if [ $(find ${destdir} -maxdepth 1 -name "*.nii.gz" -type f | wc -l) = 0 ]; then
    echo "prepareTBSS(): copying FA files to tbss-directory..."
    if [ "x$TBSS_INCLUDED_SUBJECTS" = "x" -o "x$TBSS_INCLUDED_SESSIONS" = "x" ] ; then
      echo "prepareTBSS(): gathering FA-files from directory tree ($sourcedir) and copying them to tbss-directory..."
      find ${sourcedir} -name "$pttrn_files" | grep /${FAdir}/ | sort | xargs -I{} cp -v {} $destdir
    else
      for subj in $TBSS_INCLUDED_SUBJECTS ; do
        for sess in $TBSS_INCLUDED_SESSIONS ; do
          cp -v $subjdir/$subj/$sess/$FAdir/$pttrn_files $destdir
        done
      done
    fi
  else
    echo "prepareTBSS(): listing FA files in tbss-directory <${destdir}>:"
    find ${destdir} -maxdepth 1 -name "*.nii.gz" -type f 
  fi
  if [ $DEL -eq 0 ] ; then read -p "Press key to continue..." ; fi
  
  echo "prepareTBSS(): changing to ${destdir}..."
  cd ${destdir} 
  
    echo "prepareTBSS(): executing 'tbss_1_preproc *nii.gz'..."
    tbss_1_preproc *nii.gz

    echo "prepareTBSS(): executing 'tbss_2_reg $reg_opt'..."
    tbss_2_reg "$reg_opt"

    waitIfBusy # ...because tbss_2_reg uses fsl_sub

    echo "prepareTBSS(): executing 'tbss_3_postreg -S'..."
    tbss_3_postreg -S  

  cd $wd
}

function thres_skeleton()
{
  local tdir="$1"
  local thres="$2"
  local DEL="$3"
  local wd=`pwd`
  
  if [ ! -d $tdir/stats ] ; then echo "thres_skeleton(): Directory <$tdir/stats> does not exist. Aborting." ; return ; fi
  
  echo "thres_skeleton(): changing to <${tdir}>..." 
  cd ${tdir}  
    if [ -d stats_${thres} -a $DEL -eq 0 ] ; then read -p "thres_skeleton(): Directory <${tdir}/stats_${thres}> already exists. Press any key to delete it or Control-C to abort..." ; rm -r stats_${thres} ; fi
    if [ -d stats_${thres} -a $DEL -eq 1 ] ; then echo "thres_skeleton(): WARNING: Directory <${tdir}/stats_${thres}> already exists - deleting it as requested in 5 seconds !" ; sleep 5 ; rm -r stats_${thres} ; fi
    
    echo "thres_skeleton(): copying files to folder: <stats_${thres}>..."  # (copying rather than linking to ensure compatibility with fsl's tbssx script)
    mkdir -p stats_${thres}
    cp ./stats/all_FA.nii.gz ./stats_${thres}/
    cp ./stats/mean_FA.nii.gz ./stats_${thres}/
    cp ./stats/mean_FA_mask.nii.gz ./stats_${thres}/    
    cp ./stats/mean_FA_skeleton.nii.gz ./stats_${thres}/
    #cp -v ./stats/*.nii.gz ./stats_${thres}/
    
    echo "thres_skeleton(): changing to <stats_${thres}>"  
    cd stats_${thres}    
      echo "thres_skeleton(): executing 'tbss_4_prestats $thres'..."  
      fsl_sub tbss_4_prestats $thres ; # ignore error "cd: 88: can't cd to stats" (!)
  cd $wd  
}

function prepareVBM()
{ 
  local sourcedir=$1   
  local destdir=$2
  local pttrn_files_struc="$3"
  local pttrn_files_brain="$4"
  local DEL="$5"
  local strucs="" ; local struc=""
  local brains="" ; local brain=""
  local files=""
  local wd=`pwd`   # define current dir.
    
  # vbm destinaton dir already present ?
  if [ -d ${destdir} -a $DEL -eq 0 ] ; then read -p "prepareVBM(): Directory <${destdir}> already exists. Press any key to continue or Control-C to abort..." ; fi
  if [ -d ${destdir} -a $DEL -eq 1 ] ; then 
    if [ `echo ${destdir} | grep $vbmdir | wc -l` -eq 0 ] ; then # test, whether destination paths is plausible to avoid accidental deletions
      echo "prepareVBM(): ERROR: The destination path ($destdir) is not under the vbm directory ($vbmdir). No deletions made. Exiting..." ; exit 1
    else 
      echo "prepareVBM(): WARNING: Directory <${destdir}> already exists - deleting it as requested in 5 seconds !" ; sleep 5
      rm -r ${destdir}
    fi
  fi
      
  # create directory
  mkdir -p $destdir/struc
  
  # change to vbm directory
  echo "prepareVBM(): changing to <$destdir>..."
  cd $destdir      
      # are files already present for processing ? Otherwise copy strucs and skull-stripped brains from subjdir...
      if [ $(find ${destdir} -maxdepth 1 -name "*.nii.gz" -type f | wc -l) = 0 ]; then
        echo "prepareVBM(): copying structurals to <$destdir>..."
        if [ "x$VBM_INCLUDED_SUBJECTS" = "x" -o "x$VBM_INCLUDED_SESSIONS" = "x" ] ; then
          echo "prepareVBM(): gathering files (structurals & brain-extracted) from directory tree ($sourcedir) and copying them to <$destdir>..."
          strucs=`find ${sourcedir} -name "$pttrn_files_struc" | sort | xargs -I{} remove_ext {}`
          brains=`find ${sourcedir} -name "$pttrn_files_brain" | sort | xargs -I{} remove_ext {}`
          
          for struc in $strucs ; do cp -v ${struc}.nii.gz ./$(basename $struc | cut -d _ -f1)_struc.nii.gz ; done
          for brain in $brains ; do cp -v ${brain}.nii.gz ./$(basename $brain | cut -d _ -f1)_struc_brain.nii.gz ; done
        else        
          if [ $VBM_USE_FS_LONGT -eq 1 ] ; then
            cp $scriptdir/LIA_to_LAS_conformed.mat $destdir/
            for subj in $VBM_INCLUDED_SUBJECTS ; do
              mri_convert $FS_subjdir/$subj/mri/nu.mgz $destdir/${subj}_longt-struc.nii.gz -odt float
              mri_convert $FS_subjdir/$subj/mri/brain.mgz $destdir/${subj}_longt-struc_brain.nii.gz
              fslmaths $destdir/${subj}_longt-struc_brain.nii.gz -bin $destdir/${subj}_longt-brainmask -odt char ;
              fslmaths $destdir/${subj}_longt-struc.nii.gz -mas $destdir/${subj}_longt-brainmask $destdir/${subj}_longt-struc_brain.nii.gz
              cp $FS_subjdir/$subj/mri/transforms/*_to_${subj}.lta $destdir/
              for sess in $VBM_INCLUDED_SESSIONS ; do
                mri_convert --conform $subjdir/$subj/$sess/vbm/$(subjsess)_t1_nu_struc.nii.gz $destdir/$(subjsess)_struc.nii.gz -odt float
                #mri_convert $FS_subjdir/$(subjsess)/mri/nu.mgz $destdir/$(subjsess)_struc.nii.gz -odt float
                mri_convert $FS_subjdir/$(subjsess)/mri/brain.mgz $destdir/$(subjsess)_struc_brain.nii.gz
                fslmaths $destdir/$(subjsess)_struc_brain.nii.gz -bin $destdir/$(subjsess)_brainmask -odt char ;
                fslmaths $destdir/$(subjsess)_struc.nii.gz -mas $destdir/$(subjsess)_brainmask $destdir/$(subjsess)_struc_brain.nii.gz              
              done
            done
          else
            for subj in $VBM_INCLUDED_SUBJECTS ; do
              for sess in $VBM_INCLUDED_SESSIONS ; do            
                cp -v $subjdir/$subj/$sess/vbm/$pttrn_files_struc $destdir/$(subjsess)_struc.nii.gz
                cp -v $subjdir/$subj/$sess/vbm/$pttrn_files_brain $destdir/$(subjsess)_struc_brain.nii.gz
              done
            done
          fi
        fi
      else
        echo "prepareVBM(): listing structural volumes in vbm-directory <${destdir}>:"
        files=`find ${destdir} -maxdepth 1 -name "*.nii.gz" -type f`
        echo $files | row2col
      fi
      if [ $DEL -eq 0 ] ; then read -p "Press key to continue..." ; fi
      
      # checking whether number of *struc and *struc_brain files are plausible
      files=`find ${destdir} -maxdepth 1 -name "*.nii.gz" -type f`
      brains=`echo $files | row2col | grep _struc_brain.nii.gz || true` # added '|| true' to avoid abortion by 'set -e' statement
      strucs=`echo $files | row2col | grep _struc.nii.gz || true` # added '|| true' to avoid abortion by 'set -e' statement
      if [ ! $(echo "$strucs" | wc -w) -eq $(echo "$brains" | wc -w) ] ; then read -p "prepareVBM(): ERROR : Number of structural images does not match number of brain-extracted images! Press Key to exit..." ; exit 1 ; fi
 
      # move to struc directory after deleting contents from prev. run
      echo "prepareVBM(): deleting contents of <$destdir/struc>..."
      rm -f ./struc/*
      echo "prepareVBM(): moving files to <$destdir/struc>..."
      mv -v ./*.* ./struc/

      # nonlinear registration (=recommended)
      if [ $VBM_USE_FS_LONGT -eq 1 ] ; then
        echo "prepareVBM(): executing 'longt_fslvbm_2_template.sh -n'..."
        $scriptdir/longt_fslvbm_2_template.sh -n
      else
        echo "prepareVBM(): executing 'fslvbm_2_template -n'..."
        fslvbm_2_template -n
      fi

      waitIfBusy # ...because fslvbm_2_template uses fsl_sub

      # may need to run 'Glm' before in order to create design... (but seems to work - ignore errors in fslvbm3b.e* in stats folder inasmuch they are related to a failing randomise call [there are no design files in that folder])
      if [ $VBM_USE_FS_LONGT -eq 1 ] ; then
        echo "prepareVBM(): executing 'longt_fslvbm_3_proc.sh'..."
        $scriptdir/longt_fslvbm_3_proc.sh
      else
        echo "prepareVBM(): executing 'fslvbm_3_proc'..."
        fslvbm_3_proc # (!)
      fi

      waitIfBusy # ...because fslvbm_3_proc uses fsl_sub
  cd $wd
}

function vbm_smooth()
{
  local vdir="$1"
  local smooth="$2"
  local DEL="$3"
  local wd=`pwd`
  
  if [ ! -d $vdir/stats ] ; then echo "vbm_smooth(): Directory <$vdir/stats> does not exist. Aborting." ; return ; fi
  
  echo "vbm_smooth(): changing to <$vdir>..."
  cd ${vdir}
    if [ -d stats_s${smooth} -a $DEL -eq 0 ] ; then read -p "vbm_smooth(): Directory <${vdir}/stats_s${smooth}> already exists. Press any key to delete it or Control-C to abort..." ; rm -r stats_s${smooth} ; fi
    if [ -d stats_s${smooth} -a $DEL -eq 1 ] ; then echo "vbm_smooth(): WARNING: Directory <${vdir}/stats_s${smooth}> already exists - deleting it as requested in 5 seconds !" ; sleep 5 ; rm -r stats_s${smooth} ; fi
    
    echo "vbm_smooth(): linking files to folder: <stats_s${smooth}>..."  
    mkdir -p stats_s${smooth} 
    ln -sfv ../stats/GM_mask.nii.gz ./stats_s${smooth}/
    ln -sfv ../stats/GM_mod_merg.nii.gz ./stats_s${smooth}/
    
    echo "vbm_smooth(): changing to <stats_s${smooth}>..."
    cd stats_s${smooth}
      echo "vbm_smooth(): smoothing modulated GM with $smooth mm..."
      fslmaths GM_mod_merg -s $smooth GM_mod_merg_smoothed
      echo "$smooth" > kernel.txt
  cd $wd  
}


function prepareALFF()
{
  local sourcedir="$1"
  local ALFFdir="$2"
  local destdir="$3"
  local pttrn_ALFF="$4"
  local pttrn_fALFF="$5"
  local maskfunc="$6"
  local ztransform2ndlev="$7"
  local DEL="$8"
  
  local wd=`pwd` # define crurrent working directory
  local list=""
  local i=0
  local alff_list=""
  lcoal falff_list=""
  local alffZ_list=""
  local falffZ_list=""
  
  # tbss subdir already present ?
  if [ -d ${destdir} -a $DEL -eq 0 ] ; then read -p "prepareALFF(): Directory <${destdir}> already exists. Press any key to continue or Control-C to abort..." ; fi
  if [ -d ${destdir} -a $DEL -eq 1 ] ; then 
    if [ `echo ${destdir} | grep $alffdir | wc -l` -eq 0 ] ; then # test, whether destination paths is plausible to avoid accidental deletions
      echo "prepareALFF(): ERROR: The destination path ($destdir) is not under the tbss directory ($alffdir). No deletions made. Exiting..." ; exit 1
    else 
      echo "prepareALFF(): WARNING: Directory <${destdir}> already exists - deleting it as requested in 5 seconds !" ; sleep 5
      rm -r ${destdir}
    fi
  fi
  
  # create directory
  echo $destdir
  mkdir -p ${destdir}
  
  # are files already present for processing ? Otherwise copy from subjdir...
  if [ $(find ${destdir} -maxdepth 1 -name "*.nii.gz" -type f | wc -l) = 0 ]; then
    echo "prepareALFF(): copying ALFF maps to ALFF-directory..."
    
    list=""
    for subj in $ALFF_INCLUDED_SUBJECTS ; do
      for sess in $ALFF_INCLUDED_SESSIONS ; do
        cp -v $subjdir/$subj/$sess/$ALFFdir/$pttrn_ALFF $destdir
        cp -v $subjdir/$subj/$sess/$ALFFdir/$pttrn_fALFF $destdir
        list=$list" "$subjdir/$subj/$sess/$ALFFdir/$maskfunc
      done
    done
    
  else
    echo "prepareALFF(): listing ALFF maps in ALFF-directory <${destdir}>:"
    list=$(find ${destdir} -maxdepth 1 -name "*.nii.gz" -type f)
    for i in $list ; do echo $i ; done
  fi
  if [ $DEL -eq 0 ] ; then read -p "Press key to continue..." ; fi
  
  echo "prepareALFF(): changing to ${destdir}..."
  cd ${destdir} 
  
  # normalise using group mask or use natively normalised volumes
  if [ $ztransform2ndlev -eq 1 ] ; then
  
    echo "prepareALFF(): estimating group brain-mask..."
    #fslmerge -t $destdir/mean_merged $list
    #fslmaths $destdir/mean_merged -Tmean $destdir/mean_grp
    #bet2 $destdir/mean_grp $destdir/brain_grp -f 0.3 ; fslmaths $destdir/brain_grp -bin $destdir/brain_mask
    fslmerge -t $destdir/mask_merged $list
    fslmaths $destdir/mask_merged -Tmin $destdir/brain_mask  
  
    echo "prepareALFF(): normalizing ALFF/fALFF to Z-score across full brain..."
    
    alff_list=`${FSLDIR}/bin/imglob $pttrn_ALFF`
    alffZ_list=""
    rm -f mean_ALFF.txt std_ALFF.txt filelist_ALFF.txt
    echo "prepareALFF(): normalizing ALFF to Z-score across full brain..."
    for i in $alff_list ; do
      echo "$i" >> filelist_ALFF.txt
      fslstats $i -k brain_mask -m >> mean_ALFF.txt ; mean=$( tail -n1 mean_ALFF.txt )
      fslstats $i -k brain_mask -s >> std_ALFF.txt ; std=$( tail -n1 std_ALFF.txt )
      echo "prepareALFF(): normalizing '$i':"
      echo "    mean: $mean std: $std"
      #fslmaths $i -sub ${mean} -div ${std} -mas brain_mask ${i}_Z.nii.gz
      fslmaths $i -sub ${mean} -div ${std} ${i}_Z.nii.gz
      alffZ_list=$alffZ_list" "${i}_Z.nii.gz
    done
       
    
    falff_list=`${FSLDIR}/bin/imglob $pttrn_fALFF`
    falffZ_list=""
    rm -f mean_fALFF.txt std_fALFF.txt filelist_fALFF.txt
    echo "prepareALFF(): normalizing fALFF to Z-score across full brain..."
    for i in $falff_list ; do
      echo "$i" >> filelist_fALFF.txt
      fslstats $i -k brain_mask -m >> mean_fALFF.txt ; mean=$( tail -n1 mean_fALFF.txt )
      fslstats $i -k brain_mask -s >> std_fALFF.txt ; std=$( tail -n1 std_fALFF.txt )
      echo "prepareALFF(): normalizing '$i':"
      echo "    mean: $mean std: $std"
      #fslmaths $i -sub ${mean} -div ${std} -mas brain_mask ${i}_Z.nii.gz
      fslmaths $i -sub ${mean} -div ${std} ${i}_Z.nii.gz
      falffZ_list=$falffZ_list" "${i}_Z.nii.gz
    done

    echo "prepareALFF(): merging results..."
    fslmerge -t ALFF_Z_merged.nii.gz $alffZ_list
    fslmerge -t fALFF_Z_merged.nii.gz $falffZ_list
    
    #cleanup
    imrm $alff_list
    imrm $falff_list
    #imrm $alffZ_list
    #imrm $falffZ_list
  
  else
  
    alffZ_list=`${FSLDIR}/bin/imglob $pttrn_ALFF`
    falffZ_list=`${FSLDIR}/bin/imglob $pttrn_fALFF`
    
    rm -f filelist_ALFF_Z.txt filelist_fALFF_Z.txt    
    for i in $alffZ_list ; do
      echo "$i" >> filelist_ALFF_Z.txt
    done  
    for i in $falffZ_list ; do
      echo "$i" >> filelist_fALFF_Z.txt
    done
  
    echo "prepareALFF(): merging results..."
    fslmerge -t ALFF_Z_merged.nii.gz $alffZ_list
    fslmerge -t fALFF_Z_merged.nii.gz $falffZ_list  
  fi
  
  cd $wd
}
 
function _randomise()
{
  local wd=`pwd`
  local stats_dir=$1
  local prefix=$2
  local input4D=$3
  local _opts=$4
  local ztransform=$5
  local mask=$6 # masking is useful if z-transforming (otw. just enter a dummy filename)
  local randparallel=$7
  local design=""
  local opts=""
  
  if [ $# -lt 7 ] ; then echo "_randomise(): Usage: _randomise <stats-folder> <prefix> <input4D> <cmd-options> <use z-transform> <mask-file> <use randomise_parallel>" ; exit 1 ; fi
  
  if [ ! -f $stats_dir/designs ] ; then echo "_randomise(): ERROR: textfile with pre-specified designs not found - exiting..." ; exit 1 ; fi
  
  if [ $(imtest $stats_dir/$input4D) -eq 0 ] ; then echo "_randomise(): ERROR: input file '$stats_dir/$input4D' not found - exiting..." ; exit 1 ; fi
    
  if [ $ztransform -eq 1 ] ; then
    echo "_randomise(): z-transforming '$input4D' (4D) in folder <$stats_dir>..."
    ztransf4D $stats_dir/$input4D $stats_dir/$mask $stats_dir
  fi
  
  echo "_randomise(): changing to <$stats_dir>"
  cd $stats_dir
       
    for design in `cat ./designs` ; do
      if [ ! -d $design ] ; then  "_randomise(): design-folder <$design> not found - continuing loop..." ; continue ; fi
            
      echo "_randomise(): changing to <$stats_dir/$design>"
      cd $design      
          # clean-up unfinished runs
          rm -rf ${prefix}_${design}_logs ; rm -f ${prefix}_${design}_SEED*.nii.gz ${prefix}_${design}.generate ${prefix}_${design}.defragment
          
          # shall we use the z-transformed FA maps ?
          if [ $ztransform -eq 1 -a $(echo "$design" | grep ^zVI_ | wc -l) -eq 1 ] ; then z=ztransf_ ; fi 
          
          # define randomise options
          opts="-i ../${z}${input4D} -o ${prefix}_${design} $_opts"  #-m ../GM_mask -d design.mat -t design.con -T -V -D -x -n $n_perm"
                
          if [ -f design.fts ] ; then          
            if [ $randparallel -eq 1 ] ; then 
              echo "randomise_parallel $opts -f design.fts" > randomise.cmd
            else
              echo "fsl_sub -l $logdir -N randomise_${stats_dir##*/}_${design} randomise $opts -f design.fts" > randomise.cmd
            fi
          else
            if [ $randparallel -eq 1 ] ; then           
              echo "randomise_parallel $opts" > randomise.cmd
            else
              echo "fsl_sub -l $logdir -N randomise_${stats_dir##*/}_${design} randomise $opts" > randomise.cmd
            fi        
          fi
          
          # execute command
          echo "_randomise(): executing command:"
          echo "  '`cat randomise.cmd`'"
          source randomise.cmd
      cd ..    
      if [ $randparallel -eq 1 ] ; then waitIfBusy ; fi # only useful when used in conjunction with randomise_parallel
    done  
  
  waitIfBusy
  
  cd $wd
}

